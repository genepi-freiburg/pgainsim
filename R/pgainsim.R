#' Simulation of recessive, additive and dominant p-gains under specified genetic association, the default is no genetic association.
#'
#' The genotype data is simulated in Hardy-Weinberg equilibrium as binomial distributed samples of size n_study with probability depending on the fixed allele frequencies AFs.
#' To simulate additive, recessive and dominant p-gains under the specified genetic association sim_MOI with specified effect_size traits corresponding to a genotype are generated by random draws of a normally distributed sample with a mean based on sim_MOI and effect_size and with a specified trait_variance.
#' E.g. for a simulation under additive association with genotypes AA, AB, BB we have trait(AA)~N(0,trait_variance), trait(AB)~N(effect_size,trait_variance), trait(BB)~N(2*effect_size,trait_variance).
#' The p-values of the additive, recessive and dominat model are computed by applying linear regression with the additive, recessive and dominant dosage respectively as independent variable on the simulated trait and genotype data.
#' Based on the p-values of the three different models the additive, recessive and the dominant p-gains are computed for every allele frequency of AFs.
#'
#' @name p_gain_simulation
#' @param pgain_types    Character vector of the types of p-gains, which should be simulated. "add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain (default = c("add","rec")).
#' @param AFs    Numeric vector of assumed allele frequencies.
#' @param effect_size    Numeric value of assumed effect_size. Default is no genetic effect (default = 0).
#' @param trait_variance    Positive numeric value of assumed trait variance within a genotype (default = 1). 
#' @param sim_MOI   Character describing the mode of inheritance (MOI) based on that the simulation is performed. "add" means additive MOI, "rec" means recessive MOI and "dom" means dominant MOI. By default the simulation is performed under the assumption of no genetic association (default = "none").
#' @param n    Integer. The number of random draws.
#' @param n_study    Integer. The number of samples per simulation / study size (default = 1000L).
#' @param cores    Integer. Amount of CPU cores used (<=1 : sequential)
#' @return list_pgains_AF list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Each column describes simulated p-gain-values for the allele frequency, which is in the column name. The last data frame in the list has 1 row and 3 columns with information about the chosen sim_MOI, effect_size and trait_variance.
#'
#' @examples
#' sim_dat <- p_gain_simulation(pgain_types=c("add","rec"),AFs=c(0.3,0.7),n=10000L, cores=4L)
#'
#' @export
p_gain_simulation<-function(pgain_types=c("add","rec"),AFs, effect_size=0, trait_variance=1, sim_MOI="none" ,n=100000L,n_study=1000L,cores=2L)
{

if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% c("add","rec","dom")))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom.")

if (is.null(AFs) || !is.numeric(AFs))
stop("pgainsim: Error: AFs must be a numeric.")

if (is.null(effect_size) || !is.numeric(effect_size))
stop("pgainsim: Error: effect_size must be a numeric.")

if (is.null(trait_variance) || !is.numeric(trait_variance) || trait_variance<=0)
stop("pgainsim: Error: trait_variance must be a positive numeric.")

if (is.null(sim_MOI) || !is.character(sim_MOI) || !sim_MOI %in% c("add","rec","dom","none") || !length(sim_MOI)==1)
stop("pgainsim: Error: sim_MOI must be a character of the type add, rec, dom or none.")

if (sim_MOI=="none" & !effect_size==0)
stop("pgainsim: Error: When no genetic effect should be simulated with sim_MOI=\"none\" (default), the effect size should be 0 (default)")

if (is.null(n) || !is.integer(n))
stop("pgainsim: Error: n must be an integer.")

if (is.null(n_study) || !is.integer(n_study))
stop("pgainsim: Error: n_study must be an integer.")

if (is.null(cores) || !is.integer(cores))
stop("pgainsim: Error: cores must be an integer.")

if (is.null(n) || !is.integer(n))
stop("pgainsim: Error: n must be an integer.")
if (is.integer(n))
print(paste0("Generating ",n," random draws."))


if ("rec"%in%pgain_types){
    pgain_AF_rec <- vector("list",length(AFs))
}

if ("add"%in%pgain_types){
    pgain_AF_add <- vector("list",length(AFs))
}

if ("dom"%in%pgain_types){
    pgain_AF_dom <- vector("list",length(AFs))
}


for(k in 1:length(AFs)){
    AF <- AFs[k]
    pvals <- parallel::mclapply(X=1:n,FUN=function(j){
 
        pval1<-pval2<-pval3<-rep(NA, 1)
        
		genotype <- rbinom(n=n_study,size=2,prob=AF)

		trait <- rep(NA, n_study)
		

		if (sim_MOI=="none"){
			trait <- rnorm(n_study, 0, sqrt(trait_variance))
		}
		
		if (sim_MOI=="add"){
			trait[genotype==0] <- rnorm(length(genotype[genotype==0]),0,sqrt(trait_variance))
			trait[genotype==1] <- rnorm(length(genotype[genotype==1]),effect_size,sqrt(trait_variance))
			trait[genotype==2] <- rnorm(length(genotype[genotype==2]),2*effect_size,sqrt(trait_variance))
		}
		
		if (sim_MOI=="rec"){
			trait[genotype==0] <- rnorm(length(genotype[genotype==0]),0,sqrt(trait_variance))
			trait[genotype==1] <- rnorm(length(genotype[genotype==1]),0,sqrt(trait_variance))
			trait[genotype==2] <- rnorm(length(genotype[genotype==2]),effect_size,sqrt(trait_variance))
		}

		if (sim_MOI=="dom"){
			trait[genotype==0] <- rnorm(length(genotype[genotype==0]),0,sqrt(trait_variance))
			trait[genotype==1] <- rnorm(length(genotype[genotype==1]),effect_size,sqrt(trait_variance))
			trait[genotype==2] <- rnorm(length(genotype[genotype==2]),effect_size,sqrt(trait_variance))
		}	
			
            rec_tmp <- replace(genotype, genotype==1,0)
            rec_dosage <- replace(rec_tmp,rec_tmp==2,1)
            add_dosage <- genotype
            dom_dosage <- replace(genotype, genotype==2,1)
		
		          

            if (nrow(summary(lm(trait~dom_dosage))$coefficients)==2){
                pval1[1]<-summary(lm(trait~dom_dosage))$coefficients[2,4]
            }else{
                pval1[1] <- 1
            }

            if (nrow(summary(lm(trait~rec_dosage))$coefficients)==2){
                pval2[1]<-summary(lm(trait~rec_dosage))$coefficients[2,4]
            }else{
                pval2[1] <- 1
            }

            if (nrow(summary(lm(trait~add_dosage))$coefficients)==2){
                pval3[1]<-summary(lm(trait~add_dosage))$coefficients[2,4]
            }else{
                pval3[1] <- 1
            }
        

        return(cbind(pval1,pval2,pval3))
    },mc.cores=cores)

    pvals <- do.call("rbind",pvals)

    if ("rec"%in%pgain_types){
        test2_rec<-cbind(apply(pvals[,c(1,3)],1,min), pvals[,2])
        pgain_rec<-test2_rec[,1]/test2_rec[,2]

        pgain_tmp_rec <- data.frame(AF=AF,pgain_rec=pgain_rec)
        colnames(pgain_tmp_rec)[2] <- as.character(AFs[k])
        pgain_AF_rec[[k]] <- pgain_tmp_rec[,2, drop=FALSE]
    }

    if ("add"%in%pgain_types){
        test2_add <- cbind(apply(pvals[,c(1,2)],1,min), pvals[,3])
        pgain_add <- test2_add[,1]/test2_add[,2]

        pgain_tmp_add <- data.frame(AF=AF,pgain_add=pgain_add)
        colnames(pgain_tmp_add)[2] <- as.character(AFs[k])
        pgain_AF_add[[k]] <- pgain_tmp_add[,2, drop=FALSE]
    }

    if ("dom"%in%pgain_types){
        test2_dom <- cbind(apply(pvals[,c(2,3)],1,min), pvals[,1])
        pgain_dom <- test2_dom[,1]/test2_dom[,2]

        pgain_tmp_dom <- data.frame(AF=AF,pgain_dom=pgain_dom)
        colnames(pgain_tmp_dom)[2] <- as.character(AFs[k])
        pgain_AF_dom[[k]] <- pgain_tmp_dom[,2, drop=FALSE]
    }

}

if ("rec"%in%pgain_types){
    pgain_AF_rec <- do.call(cbind,pgain_AF_rec)
}
if ("add"%in%pgain_types){
    pgain_AF_add <- do.call(cbind,pgain_AF_add)
}
if ("dom"%in%pgain_types){
    pgain_AF_dom <- do.call(cbind,pgain_AF_dom)
}

name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
    name_pgains[m] <- paste0("pgain_AF_",pgain_types[m])
}

if (length(pgain_types)==1){
    list_pgains_AF <- list(get(name_pgains[1]), params_info=data.frame(sim_MOI=sim_MOI, effect_size=effect_size, trait_variance=trait_variance))
}

if (length(pgain_types)==2){
    list_pgains_AF <- list(get(name_pgains[1]), get(name_pgains[2]), params_info=data.frame(sim_MOI=sim_MOI, effect_size=effect_size, trait_variance=trait_variance))
}

if (length(pgain_types)==3){
    list_pgains_AF <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]), params_info=data.frame(sim_MOI=sim_MOI, effect_size=effect_size, trait_variance=trait_variance))
}

names(list_pgains_AF) <- c(pgain_types, "params_info")

invisible(list_pgains_AF)
}


#' Plot density of the p-gain for a specified model for different allele frequencies based on the result of the function p_gain_simulation
#'
#' @name p_gain_density_plot
#' @param pgain_type    Character of the type of p-gain, which was simulated in the function p_gain_simulation and from which the density should be plotted for the different allele frequencies. ("add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain)
#' @param sim_data    list of data frames. For the requested type of p-gain there is a data frame. Each column describes simulated p-gain-values for the allele frequency, which is in the column name. Output of function p_gain_simulation.
#' @param xlim    numeric vector with two values specifying the left and the right limit of the x-axis. The default depends on the range of the data, but for getting a better view of the p-gain density a lower value of th right limit of the x-axis is recommended.
#' @param bw    The smoothing bandwidth to be used, same argument as in ggplot with same default. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in stats::bw.nrd().
#' @param adjust    numeric value describing a multiplicate bandwidth adjustment, same argument as in ggplot with same default. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For example, adjust = 1/2 means use half of the default bandwidth.
#' @param col    Character vector with names of colours that are used to plot the density of the p-gain for different allele frequencies. col has the same length as AFs. The default are the default colours of ggplot.
#' @param print_pdf    logical value indicating whether the density is plotted as PDF-file or within the R-session. Default is TRUE.
#' @return    Plot of densities of the p-gain of type pgain_type for all allele frequencies in AFs. If pgain_type="add" and sim_MOI="none" or "add" allele frequencies AF and 1-AF are combined.
#'
#' @examples
#' sim_dat <- p_gain_simulation(pgain_types=c("add","rec"),AFs=c(0.3,0.7),n=10000L, cores=4L)
#' p_gain_density_plot(pgain_type="rec", sim_data=sim_dat, xlim=c(0,5))
#'
#' @export
p_gain_density_plot<-function(pgain_type="rec", sim_data, xlim=c(0,NA), bw="nrd0", adjust=1 ,col=hcl(h=seq(15, 375, length = ncol(sim_data[[1]])+1), l=65,c=100)[1:ncol(sim_data[[1]])], print_pdf=TRUE)
{
if (is.null(pgain_type) || !(pgain_type %in% c("add", "rec", "dom")) || !(length(pgain_type)==1) ||!(pgain_type %in% names(sim_data)))
stop("pgainsim: Error: pgain_type must be a character vector of length 1 and of the type add, rec or dom and the type of the p-gain must be contained in sim_data.")

if (is.null(sim_data) || !is.list(sim_data) || !(pgain_type %in% names(sim_data)))
stop("pgainsim: Error: sim_data must be a list with a data frame named pgain_type.")

if (is.null(xlim) || !is.numeric(xlim) || !(length(xlim)==2))
stop("pgainsim: Error: xlim must be a numeric vector of length 2.")

if (is.null(col) || !is.character(col) || !(length(col)==ncol(sim_data[[1]])))
stop("pgainsim: Error: col must be a character vector with names of colours and with the same length as AFs.")

if (is.na(xlim[2])){
warning("xlim is not specified. Consider to set xlim manually with a lower value for the right limit for the x-axis.")
}

AFs <- as.numeric(colnames(sim_data[[1]]))

index <- which(names(sim_data) == pgain_type)

df_type <- sim_data[[index]]
rm_AF <- rep(0,length(AFs))

for(i in 1:length(AFs)){
AF <- AFs[i]
if (max(df_type[,i]) < 1){
tex <- paste0("The maximal simulated p-gain for allele frequency ",AF," was < 1. No density plot returned for allele frequency ",AF,".")
print(tex)
rm_AF[i] <- 1
}   
}

index_AF <- which(rm_AF==0)

if (length(index_AF)==0){
print("The maximal simulated p-gain for all specified allele frequencies was < 1 hence no density plot returned.")
}else{

AFs_new <- AFs[index_AF]

df_type_new <- as.data.frame(df_type[,index_AF])
colnames(df_type_new) <- as.character(AFs_new)

df_type_new$id <- rownames(df_type_new)

res_type <- reshape2::melt(df_type_new, id.vars="id")



if (pgain_type=="add" & (sim_data[[length(sim_data)]][1,1]=="none" || sim_data[[length(sim_data)]][1,1]=="add" || sim_data[[length(sim_data)]][1,2]==0)){

for(i in 1:length(AFs_new)){

AF <- AFs_new[i]


if ((AF < 0.5) & (as.character(1-AF) %in% as.character(AFs_new))){

res_type[res_type$variable==1-AF,2] <- AF

}

}

}

colnames(res_type)[colnames(res_type)=="variable"] <- "AF"
density_plot <- ggplot2::ggplot(res_type, aes(x=value, color=AF)) + geom_density(bw=bw, adjust=adjust)+ scale_color_manual(values =col) + xlim(xlim[1],xlim[2]) + geom_vline(xintercept = 1, col="black", lty=2) + xlab(paste0(pgain_type," p-gain")) + ylab("density") + theme_classic()

if(print_pdf==TRUE){
pdf(paste0("density_plot_pgain_",pgain_type,".pdf"))
print(density_plot)
dev.off()
}else{
print(density_plot)
}
}
}


#' Computation of p-gain-quantiles for numbers of tests based on the result of function p_gain_simulation.
#'
#' @name p_gain_quantiles
#' @param pgain_types    Character vector of the types of p-gains, which were simulated in the function p_gain_simulation and from which quantiles should be computed. ("add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain) (default = names(sim_data)).
#' @param n_tests    Integer. The number of tests for which the p-gain-quantile should be computed. It depends on the available number of datapoints.
#' @param sim_data    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Each column describes simulated p-gain-values for the allele frequency, which is in the column name. Output of function p_gain_simulation.
#' @return list_pgains_quant list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe p-gain-quantiles for different allele frequenciey (numeric values) and rows discribe number of tests. For the additive case with sim_MOI="none" or "add" simulated p-gain values of allele frequencies AF and 1-AF are combined before computing the quantiles. The last data frame in the list has 1 row and 3 columns with information about sim_MOI, effect_size and trait_variance chosen for the function p_gain_simulation.
#'
#' @examples
#' sim_dat <- p_gain_simulation(pgain_types=c("add","rec"),AFs=c(0.3,0.7),n=10000L, cores=4L)
#' quantile <- p_gain_quantiles(n_tests=5L,sim_data=sim_dat)
#'
#' @export
p_gain_quantiles<-function(sim_data, pgain_types=names(sim_data)[1:(length(sim_data)-1)], n_tests)
{
if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% names(sim_data)))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom and the simulated types of p-gains must be contained in sim_data.")

if (is.null(n_tests) || !is.numeric(n_tests))
stop("pgainsim: Error: n_tests must be an integer.")

if (is.null(sim_data) || !is.list(sim_data) || length(sim_data)<=length(pgain_types))
stop("pgainsim: Error: sim_data must be a list of length greater than the length of pgain_types.")

AFs <- as.numeric(colnames(sim_data[[1]]))

n_datapoints <- nrow(sim_data[[1]])

if (0.05/n_tests*n_datapoints<100){
warning(paste0("n_tests (=",n_tests,") for which the p-gain quantile should be computed is relatively large compared to the available number of datapoints which yields instable estimates. Reduce n_tests or increase the number of random draws."))
}

number_tests <- c(1:n_tests)

alphas <- 0.05/number_tests

if ("add"%in%pgain_types){
list_pgain_quantile_add <- vector("list",length=length(AFs))
}
if ("rec"%in%pgain_types){
list_pgain_quantile_rec <- vector("list",length=length(AFs))
}
if ("dom"%in%pgain_types){
list_pgain_quantile_dom <- vector("list",length=length(AFs))
}


index_comb <- rep(0,length(AFs))

for(i in 1:length(AFs)){

AF <- AFs[i]

if ("add"%in%pgain_types){
index_add <- grep("add", names(sim_data), fixed=TRUE)
res_tmp_add <- sim_data[[index_add]][,i]


if ("add"%in%pgain_types & (sim_data[[length(sim_data)]][1,1]=="none" || sim_data[[length(sim_data)]][1,1]=="add" || sim_data[[length(sim_data)]][1,2]==0)){

if (as.character(1-AF) %in% as.character(AFs)){

index_comb[i] <- which(AFs==as.character(1-AF))

res_tmp_add <- c(sim_data[[index_add]][,i],sim_data[[index_add]][,index_comb[i]])

}
}

pgain.order_add<-res_tmp_add[order(res_tmp_add, decreasing=TRUE)]

list_pgain_quantile_add[[i]] <- as.data.frame(pgain.order_add[floor(length(pgain.order_add)*alphas)])
}


if ("rec"%in%pgain_types){
index_rec <- grep("rec", names(sim_data), fixed=TRUE)
res_tmp_rec <- sim_data[[index_rec]][,i]

pgain.order_rec<-res_tmp_rec[order(res_tmp_rec, decreasing=TRUE)]

list_pgain_quantile_rec[[i]] <- as.data.frame(pgain.order_rec[floor(length(pgain.order_rec)*alphas)])
}



if ("dom"%in%pgain_types){
index_dom <- grep("dom", names(sim_data), fixed=TRUE)
res_tmp_dom <- sim_data[[index_dom]][,i]

pgain.order_dom<-res_tmp_dom[order(res_tmp_dom, decreasing=TRUE)]

list_pgain_quantile_dom[[i]] <- as.data.frame(pgain.order_dom[floor(length(pgain.order_dom)*alphas)])
}



}




if ("rec"%in%pgain_types){
pgain_quant_rec <- do.call(cbind,list_pgain_quantile_rec)
colnames(pgain_quant_rec) <- as.character(AFs)
}
if ("add"%in%pgain_types){
pgain_quant_add <- do.call(cbind,list_pgain_quantile_add)
colnames(pgain_quant_add) <- as.character(AFs)
}
if ("dom"%in%pgain_types){
pgain_quant_dom <- do.call(cbind,list_pgain_quantile_dom)
colnames(pgain_quant_dom) <- as.character(AFs)
}

name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
name_pgains[m] <- paste0("pgain_quant_",pgain_types[m])
}

if (length(pgain_types)==1){
list_pgains_quant <- list(get(name_pgains[1]), params_info=sim_data[[length(sim_data)]])
}

if (length(pgain_types)==2){
list_pgains_quant <- list(get(name_pgains[1]), get(name_pgains[2]),params_info=sim_data[[length(sim_data)]])
}

if (length(pgain_types)==3){
list_pgains_quant <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]),params_info=sim_data[[length(sim_data)]])
}

names(list_pgains_quant) <- c(pgain_types, "params_info")


invisible(list_pgains_quant)

}



#' Computation of log-linear fit of the pgain-quantiles (dependent on the number of tests) and evaluation for a determined number of tests
#'
#' @name p_gain_quantile_fit
#' @param pgain_types    Character vector of the types of p-gains, of which the quantiles were computed in the function p_gain_quantiles. ("add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain) (default = names(pgain_quantile)).
#' @param pgain_quantile    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe pgain-quantiles for different allele frequenciey (numeric values) and rows discribe number of tests. Output of function p_gain_quantiles.
#' @param n_data_ff    Integer. Number of quantile datapoints that should be used for the plot. n_data_ff is a divider of the number of available datapoints (default = nrow(pgain_quantile[[1]])).
#' @param start_vec    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe 3 starting estimates (numeric values) for the log-linear fit for each allele frequency (default is c(1,0.01,1.01) for every p-gain type and for every allele frequency).
#' @param test_number    Integer. Number of tests for which the p-gain threshold should be determined.
#' @param col    Character vector with names of colours that are used to plot the quantiles of the p-gain for different allele frequencies. col has the same length as AFs. The default are the default colours of ggplot.
#' @param print_pdf    logical value indicating whether the quantiles are plotted as PDF-file or within the R-session. Default is TRUE.
#' @return list_fits as a list, plots of log-linear fit of the quantiles for every allele frequency, approximated quantile for test_number many tests for every allele frequency. The list contains for every p-gain type a list with the log-linear fits for every allele frequency. For the additive case with sim_MOI="none" or "add" allele frequencies AF and 1-AF are combined.
#'
#' @examples			
#' sim_dat <- p_gain_simulation(pgain_types=c("add","rec"),AFs=c(0.3,0.7),n=10000L, cores=4L)
#' quantile <- p_gain_quantiles(n_tests=5L,sim_data=sim_dat)
#' list_fits <- p_gain_quantile_fit(pgain_quantile=quantile,test_number=50L)
#'
#' @export
p_gain_quantile_fit<-function(pgain_quantile, pgain_types=names(pgain_quantile)[1:(length(pgain_quantile)-1)],n_data_ff=nrow(pgain_quantile[[1]]),start_vec=lapply(1:length(pgain_types), function(x) data.frame(matrix(rep(c(1,0.01,1.01),times=ncol(pgain_quantile[[1]])),ncol=ncol(pgain_quantile[[1]]),dimnames=list(row.names=c("a","b","d"),col.names=colnames(pgain_quantile[[1]]))))),test_number, col=hcl(h=seq(15, 375, length = ncol(pgain_quantile[[1]])+1), l=65,c=100)[1:ncol(pgain_quantile[[1]])], print_pdf=TRUE)
{

if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% names(pgain_quantile)))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom and the quantiles of the types of p-gains must be contained in pgain_quantile.")

if (is.null(pgain_quantile) || !is.list(pgain_quantile) || length(pgain_quantile)<=length(pgain_types))
stop("pgainsim: Error: pgain_quantile must be a list of length greater than the length of pgain_types.")

if (is.null(n_data_ff) || !is.integer(n_data_ff) || !nrow(pgain_quantile[[1]])%%n_data_ff==0)
stop("pgainsim: Error: n_data_ff must be an integer and a divider of the number of available datapoints.")

if (is.null(start_vec) || !is.list(start_vec) || !length(start_vec)==length(pgain_types) || !ncol(start_vec[[1]])==ncol(pgain_quantile[[1]]) || !nrow(start_vec[[1]])==3 || !sum(!(sapply(start_vec[[1]],class))=="numeric")==0)
stop("pgainsim: Error: start_vec must be a list with the same length as pgain_types and every data frame in the list must have the same number of columns as pgain_quantile[[1]] and with 3 rows and with numeric values.")

if (is.null(test_number) || !is.integer(test_number))
stop("pgainsim: Error: test_number must be an integer.")

if (is.null(col) || !is.character(col) || !(length(col)==ncol(pgain_quantile[[1]])))
stop("pgainsim: Error: col must be a character vector with names of colours and with the same length as AFs.")



AFs <- as.numeric(colnames(pgain_quantile[[1]]))

number_tests <- c(1:nrow(pgain_quantile[[1]]))








if ("rec"%in%pgain_types){

fits_rec <- vector("list",length=length(AFs))
ylim_rec <- vector("numeric",length=length(AFs))
quantile_red_rec <- vector("list",length=length(AFs))
number_tests_red_rec <- vector("list",length=length(AFs))


for(i in 1:length(AFs)){

AF <- AFs[i]

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_rec <- grep("rec", names(pgain_quantile), fixed=TRUE)
quantile_red_rec[[i]] <- pgain_quantile[[index_rec]][,i][seq(1,nrow(pgain_quantile[[index_rec]]),a)]




number_tests_red_rec[[i]] <- number_tests[seq(1,nrow(pgain_quantile[[index_rec]]),a)]

index2_rec <- grep("rec", pgain_types, fixed=TRUE)

print(paste0("Fitted function for recessive p-gain-quantiles of allele frequency ",AF))

print(fits_rec[[i]] <- minpack.lm::nlsLM(formula=pgain_quantile[[index_rec]][,i]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_rec]][1,i],b=start_vec[[index2_rec]][2,i],d=start_vec[[index2_rec]][3,i]), control=nls.lm.control(maxiter = 1000,ptol=1e-9)))


print_text_rec <- paste0("recessive p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_rec)
print(log(coef(fits_rec[[i]])[1] + coef(fits_rec[[i]])[2]*test_number,base=coef(fits_rec[[i]])[3]))

ylim_rec[i] <- log(coef(fits_rec[[i]])[1] + coef(fits_rec[[i]])[2]*test_number,base=coef(fits_rec[[i]])[3])


}


p_base_rec <- ggplot2::ggplot(data.frame(x=c(0,test_number)), aes(x)) + ylim(0,max(ylim_rec)) + theme_classic() +  xlab("Number of tests") + ylab("Recessive p-gain-quantile")


for(i in 1:length(AFs)){
p_base_rec <- local({
i=i
p_base_rec + geom_point(data=data.frame(number_tests_red_rec[[i]], quantile_red_rec[[i]]), aes(number_tests_red_rec[[i]], quantile_red_rec[[i]], col=as.character(AFs[i]) ), size=1) + stat_function(fun=function(x)log(coef(fits_rec[[i]])[1] + coef(fits_rec[[i]])[2]*x,base=coef(fits_rec[[i]])[3]), geom="line", col=col[i])
})
}


if (print_pdf==TRUE){
pdf("Plot_rec_pgain_quantile_log-linear_fit.pdf")
print(p_base_rec+scale_colour_manual(name="AF", values = col))
dev.off()
}else{
print(p_base_rec+scale_colour_manual(name="AF", values = col))
}



}





if ("dom"%in%pgain_types){

fits_dom <- vector("list",length=length(AFs))
ylim_dom <- vector("numeric",length=length(AFs))
quantile_red_dom <- vector("list",length=length(AFs))
number_tests_red_dom <- vector("list",length=length(AFs))


for(i in 1:length(AFs)){

AF <- AFs[i]

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_dom <- grep("dom", names(pgain_quantile), fixed=TRUE)
quantile_red_dom[[i]] <- pgain_quantile[[index_dom]][,i][seq(1,nrow(pgain_quantile[[index_dom]]),a)]




number_tests_red_dom[[i]] <- number_tests[seq(1,nrow(pgain_quantile[[index_dom]]),a)]

index2_dom <- grep("dom", pgain_types, fixed=TRUE)

print(paste0("Fitted function for dominant p-gain-quantiles of allele frequency ",AF))

print(fits_dom[[i]] <- minpack.lm::nlsLM(formula=pgain_quantile[[index_dom]][,i]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_dom]][1,i],b=start_vec[[index2_dom]][2,i],d=start_vec[[index2_dom]][3,i]), control=nls.lm.control(maxiter = 1000,ptol=1e-9)))


print_text_dom <- paste0("dominant p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_dom)
print(log(coef(fits_dom[[i]])[1] + coef(fits_dom[[i]])[2]*test_number,base=coef(fits_dom[[i]])[3]))

ylim_dom[i] <- log(coef(fits_dom[[i]])[1] + coef(fits_dom[[i]])[2]*test_number,base=coef(fits_dom[[i]])[3])


}

p_base_dom <- ggplot2::ggplot(data.frame(x=c(0,test_number)), aes(x)) + ylim(0,max(ylim_dom)) + theme_classic() +  xlab("Number of tests") + ylab("Dominant p-gain-quantile")

for(i in 1:length(AFs)){
p_base_dom <- local({
i=i
p_base_dom + geom_point(data=data.frame(number_tests_red_dom[[i]], quantile_red_dom[[i]]), aes(number_tests_red_dom[[i]], quantile_red_dom[[i]], col=as.character(AFs[i])), size=1) + stat_function(fun=function(x)log(coef(fits_dom[[i]])[1] + coef(fits_dom[[i]])[2]*x,base=coef(fits_dom[[i]])[3]), geom="line", col=col[i])
})
}

if (print_pdf==TRUE){
pdf("Plot_dom_pgain_quantile_log-linear_fit.pdf")
print(p_base_dom+scale_colour_manual(name="AF", values = col))
dev.off()
}else{
print(p_base_dom+scale_colour_manual(name="AF", values = col))
}



}




if ("add"%in%pgain_types){



if ("add"%in%pgain_types & (pgain_quantile[[length(pgain_quantile)]][1,1]=="none" || pgain_quantile[[length(pgain_quantile)]][1,1]=="add" || pgain_quantile[[length(pgain_quantile)]][1,2]==0)){

index_comb <- rep(0,length(AFs))

for(i in 1:length(AFs)){

AF <- AFs[i]

if ((AF < 0.5) & (as.character(1-AF) %in% as.character(AFs))){

index_comb[i] <- which(AFs==as.character(1-AF))


}

}

if (sum(index_comb==0)==length(AFs)){

AFs_new <- AFs
col_new <- col

}else{

AFs_new <- AFs[-index_comb]

col_new <- col[-index_comb]

}

}else{

AFs_new <- AFs
col_new <- col

}

fits_add <- vector("list",length=length(AFs_new))
ylim_add <- vector("numeric",length=length(AFs_new))
quantile_red_add <- vector("list",length=length(AFs_new))
number_tests_red_add <- vector("list",length=length(AFs_new))


for(i in 1:length(AFs_new)){



AF <- as.character(AFs_new[i])
j <- which(as.character(AFs)==AF)

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_add <- grep("add", names(pgain_quantile), fixed=TRUE)


quantile_red_add[[i]] <- pgain_quantile[[index_add]][,j][seq(1,nrow(pgain_quantile[[index_add]]),a)]


number_tests_red_add[[i]] <- number_tests[seq(1,nrow(pgain_quantile[[index_add]]),a)]

index2_add <- grep("add", pgain_types, fixed=TRUE)

print(paste0("Fitted function for additive p-gain-quantiles of allele frequency ",AF))

print(fits_add[[i]] <- minpack.lm::nlsLM(formula=pgain_quantile[[index_add]][,j]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_add]][1,j],b=start_vec[[index2_add]][2,j],d=start_vec[[index2_add]][3,j]), control=nls.lm.control(maxiter = 1000,ptol=1e-9)))


print_text_add <- paste0("additive p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_add)
print(log(coef(fits_add[[i]])[1] + coef(fits_add[[i]])[2]*test_number,base=coef(fits_add[[i]])[3]))

ylim_add[i] <- log(coef(fits_add[[i]])[1] + coef(fits_add[[i]])[2]*test_number,base=coef(fits_add[[i]])[3])



}

p_base_add <- ggplot2::ggplot(data.frame(x=c(0,test_number)), aes(x)) + ylim(0,max(ylim_add)) + theme_classic() +  xlab("Number of tests") + ylab("Additive p-gain-quantile")

for(i in 1:length(AFs_new)){

p_base_add <- local({
i=i
p_base_add + geom_point(data=data.frame(number_tests_red_add[[i]], quantile_red_add[[i]]), aes(number_tests_red_add[[i]], quantile_red_add[[i]], col=as.character(AFs_new[i])), size=1) + stat_function(fun=function(x)log(coef(fits_add[[i]])[1] + coef(fits_add[[i]])[2]*x,base=coef(fits_add[[i]])[3]), geom="line", col=col_new[i])
})

}

if (print_pdf==TRUE){
pdf("Plot_add_pgain_quantile_log-linear_fit.pdf")
print(p_base_add+scale_colour_manual(name="AF", values = col_new))
dev.off()
}else{
print(p_base_add+scale_colour_manual(name="AF", values = col_new))
}









}








name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
name_pgains[m] <- paste0("fits_",pgain_types[m])
}

if (length(pgain_types)==1){
list_fits <- list(get(name_pgains[1]))
}

if (length(pgain_types)==2){
list_fits <- list(get(name_pgains[1]), get(name_pgains[2]))
}

if (length(pgain_types)==3){
list_fits <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]))
}



names(list_fits) <- pgain_types





invisible(list_fits)

}





