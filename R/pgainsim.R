#' Random draw of recessive (and dominant) p-gains under no association.
#'
#'		## hier kann man einen Beschreibung einfügen, hab jetzt erstmal die Kommentare aus dem Code gesammelt. Könntest du einen zusammenhängenden englsichen Text daraus machen? -> soll das ausführlicher sein?
#' To simulate additive, recessive and dominant p-gains under no association traits are generated by random draws of a standard normally distributed sample of size n_study.
#' The genotype data is simulated in Hardy-Weinberg equilibrium (independently from trait data) as corrected Bernoulli distributed samples of size n_study with probability depending on the fixed allele frequencies AFs.
#' snps_per_trait defines the number of independent SNPs per trait.
#' The p-values of the additive, recessive and dominat model are computed by applying linear regression with the additive, recessive and dominant dosage respectively as independent variable on the simulated trait and genotype data.
#' Based on the p-values of the three different models the additive, recessive and the dominant p-gains are computed for every allele frequency of AFs.
#'
#' @name p_gain_simulation
#' @param pgain_types    Character vector of the types of p-gains, which should be simulated. "add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain (default = c("add","rec")).
#' @param AFs    Numeric vector of assumed allele frequencies.
#' @param n    Integer. The number of random draws.
#' @param snps_per_trait    Integer. The number of single nucleotide polymorphisms to be simulated per random draw of the trait (default = 1L). snps_per_trait can be increased for efficient simulation. By increasing snps_per_trait you are reducing the number of independent draws of the trait.
#' @param n_study    Integer. The number of samples per simulation / study size (default = 1000L).
#' @param cores    Integer. Amount of CPU cores used (<=1 : sequential)
#' @return list_pgains_AF list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types) . Each column describes simulated p-gain-values for the allele frequency, which is in the column name.
#'
#' @examples
#' sim_data <- p_gain_simulation(pgain_types=c("add","rec"),AFs=c(0.1,0.5),n=10000L,snps_per_trait=1L,n_study=1000L,cores=2L)
#'
#' @export
p_gain_simulation<-function(pgain_types=c("add","rec"),AFs,n=100000L,snps_per_trait=1L,n_study=1000L,cores=1L)
{

if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% c("add","rec","dom")))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom.")

if (is.null(AFs) || !is.numeric(AFs))
stop("pgainsim: Error: AFs must be a numeric.")

if (is.null(n) || !is.integer(n))
stop("pgainsim: Error: n must be an integer.")

if (is.null(snps_per_trait) || !is.integer(snps_per_trait))
stop("pgainsim: Error: snps_per_trait must be an integer.")

if (is.null(n_study) || !is.integer(n_study))
stop("pgainsim: Error: n_study must be an integer.")

if (is.null(cores) || !is.integer(cores))
stop("pgainsim: Error: cores must be an integer.")

n_traits <- ceiling(n / snps_per_trait)
if(n==(n_traits*snps_per_trait)){
print(paste0("Generating ",n," random draws by drawing ",n_traits," standardnormal trait(s) with ",snps_per_trait," SNP(s) each."))
} else{
warning("The number of random draws is not a multiple of the number of SNPs per trait. Increasing the number of random draws to match.")
n <- n_traits * snps_per_trait
print(paste0("Generating ",n," random draws by drawing ",n_traits," standardnormal trait(s) with ",snps_per_trait," SNP(s) each."))
}

if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
pgain_AF_rec <- vector("list",length(AFs))
}

if (!length(grep("add", pgain_types, fixed=TRUE))==0){
pgain_AF_add <- vector("list",length(AFs))
}

if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
pgain_AF_dom <- vector("list",length(AFs))
}


for(k in 1:length(AFs)){

AF <- AFs[k]
pvals <- mclapply(X=1:n_traits,FUN=function(j){
trait <- rnorm(n_study)
pval1<-pval2<-pval3<-rep(NA, snps_per_trait)
for(i in 1:snps_per_trait)
{

#snpAA <- rbinom(n=n_study,size=1, prob=(1-AF)^2)
#snpAB <- rbinom(n=n_study,size=1,prob=2*AF*(1-AF))
#snpBB <- rbinom(n=n_study,size=1,prob=AF^2)
#correction <- rowSums(cbind(snpAA,snpAB,snpBB))
#snpAA[correction==0] <- 1
#snpAB[correction==0] <- 1
#snpBB[correction==0] <- 1
#correction <- rowSums(cbind(snpAA,snpAB,snpBB))
#snpAA <- snpAA/correction
#snpAB <- snpAB/correction
#snpBB <- snpBB/correction

#add <- snpAB + 2* snpBB
#dom <- snpAB+snpBB

#pval1[i]<-summary(lm(trait~dom))$coefficients[2,4]
#pval2[i]<-summary(lm(trait~snpBB))$coefficients[2,4]
#pval3[i]<-summary(lm(trait~add))$coefficients[2,4]

genotype <- rbinom(n=n_study,size=2,prob=AF)
rec_tmp <- replace(genotype, genotype==1,0)
rec_dosage <- replace(rec_tmp,rec_tmp==2,1)
add_dosage <- genotype
dom_dosage <- replace(genotype, genotype==2,1)

pval1[i]<-summary(lm(trait~dom_dosage))$coefficients[2,4]
pval2[i]<-summary(lm(trait~rec_dosage))$coefficients[2,4]
pval3[i]<-summary(lm(trait~add_dosage))$coefficients[2,4]
}

return(cbind(pval1,pval2,pval3))
},mc.cores=cores)

pvals <- do.call("rbind",pvals)

if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
test2_rec<-cbind(apply(pvals[,c(1,3)],1,min), pvals[,2])
pgain_rec<-test2_rec[,1]/test2_rec[,2]

pgain_tmp_rec <- data.frame(AF=AF,pgain_rec=pgain_rec)
colnames(pgain_tmp_rec)[2] <- as.character(AFs[k])
pgain_AF_rec[[k]] <- pgain_tmp_rec[,2, drop=FALSE]
}

if (!length(grep("add", pgain_types, fixed=TRUE))==0){
test2_add <- cbind(apply(pvals[,c(1,2)],1,min), pvals[,3])
pgain_add <- test2_add[,1]/test2_add[,2]

pgain_tmp_add <- data.frame(AF=AF,pgain_add=pgain_add)
colnames(pgain_tmp_add)[2] <- as.character(AFs[k])
pgain_AF_add[[k]] <- pgain_tmp_add[,2, drop=FALSE]
}

if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
test2_dom <- cbind(apply(pvals[,c(2,3)],1,min), pvals[,1])
pgain_dom <- test2_dom[,1]/test2_dom[,2]

pgain_tmp_dom <- data.frame(AF=AF,pgain_dom=pgain_dom)
colnames(pgain_tmp_dom)[2] <- as.character(AFs[k])
pgain_AF_dom[[k]] <- pgain_tmp_dom[,2, drop=FALSE]
}

}

if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
pgain_AF_rec <- do.call(cbind,pgain_AF_rec)
}
if (!length(grep("add", pgain_types, fixed=TRUE))==0){
pgain_AF_add <- do.call(cbind,pgain_AF_add)
}
if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
pgain_AF_dom <- do.call(cbind,pgain_AF_dom)
}

name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
name_pgains[m] <- paste0("pgain_AF_",pgain_types[m])
}

if (length(pgain_types)==1){
list_pgains_AF <- list(get(name_pgains[1]))
}

if (length(pgain_types)==2){
list_pgains_AF <- list(get(name_pgains[1]), get(name_pgains[2]))
}

if (length(pgain_types)==3){
list_pgains_AF <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]))
}

names(list_pgains_AF) <- pgain_types

invisible(list_pgains_AF)
}



#' Computation of p-gain-quantiles for numbers of tests based on the result of function p_gain_simulation.
#'
#' @name p_gain_quantiles
#' @param pgain_types    Character vector of the types of p-gains, which were simulated in the function p_gain_simulation and from which quantiles should be computed. ("add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain) (default = c("add","rec")).
#' @param n_tests    Integer. The number of tests for which the pgain-quantile should be computed. It depends on the available number of datapoints.
#' @param sim_data    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Each column describes simulated p-gain-values for the allele frequency, which is in the column name. Output of function p_gain_simulation.
#' @return list_pgains_quant list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe pgain-quantiles for different allele frequenciey (numeric values) and rows discribe number of tests.
#'
#' @examples
#' sim_data <- p_gain_simulation(pgain_types=c("add","rec"), AFs=c(0.1,0.5),n=10000L,snps_per_trait=1L,n_study=1000L,cores=2L)
#' pgain_quantile <- p_gain_quantiles(pgain_types=c("add","rec"), n_tests=50L,sim_data)
#'
#' @export
p_gain_quantiles<-function(pgain_types=c("add","rec"), n_tests, sim_data)
{
if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% names(sim_data)))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom and the simulated types of p-gains must be contained in sim_data.")

if (is.null(n_tests) || !is.numeric(n_tests))
stop("pgainsim: Error: n_tests must be an integer.")

if (is.null(sim_data) || !is.list(sim_data) || length(sim_data)<length(pgain_types))
stop("pgainsim: Error: sim_data must be a list of length equal or greater than the length of pgain_types.")

AFs <- as.numeric(colnames(sim_data[[1]]))

n_datapoints <- nrow(sim_data[[1]])

if (0.05/n_tests*n_datapoints<100){
warning(paste0("n_tests (=",n_tests,") for which the p-gain quantile should be computed is relatively large compared to the available number of datapoints which yields instable estimates. Reduce n_tests or increase the number of random draws."))
}

number_tests <- c(1:n_tests)

alphas <- 0.05/number_tests

if (!length(grep("add", pgain_types, fixed=TRUE))==0){
list_pgain_quantile_add <- vector("list",length=length(AFs))
}
if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
list_pgain_quantile_rec <- vector("list",length=length(AFs))
}
if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
list_pgain_quantile_dom <- vector("list",length=length(AFs))
}


for(i in 1:length(AFs)){

AF <- AFs[i]

if (!length(grep("add", pgain_types, fixed=TRUE))==0){
index_add <- grep("add", names(sim_data), fixed=TRUE)
res_tmp_add <- sim_data[[index_add]][,i]

pgain.order_add<-res_tmp_add[order(res_tmp_add, decreasing=TRUE)]

list_pgain_quantile_add[[i]] <- as.data.frame(pgain.order_add[floor(length(pgain.order_add)*alphas)])
}


if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
index_rec <- grep("rec", names(sim_data), fixed=TRUE)
res_tmp_rec <- sim_data[[index_rec]][,i]

pgain.order_rec<-res_tmp_rec[order(res_tmp_rec, decreasing=TRUE)]

list_pgain_quantile_rec[[i]] <- as.data.frame(pgain.order_rec[floor(length(pgain.order_rec)*alphas)])
}



if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
index_dom <- grep("dom", names(sim_data), fixed=TRUE)
res_tmp_dom <- sim_data[[index_dom]][,i]

pgain.order_dom<-res_tmp_dom[order(res_tmp_dom, decreasing=TRUE)]

list_pgain_quantile_dom[[i]] <- as.data.frame(pgain.order_dom[floor(length(pgain.order_dom)*alphas)])
}



}




if (!length(grep("rec", pgain_types, fixed=TRUE))==0){
pgain_quant_rec <- do.call(cbind,list_pgain_quantile_rec)
colnames(pgain_quant_rec) <- as.character(AFs)
}
if (!length(grep("add", pgain_types, fixed=TRUE))==0){
pgain_quant_add <- do.call(cbind,list_pgain_quantile_add)
colnames(pgain_quant_add) <- as.character(AFs)
}
if (!length(grep("dom", pgain_types, fixed=TRUE))==0){
pgain_quant_dom <- do.call(cbind,list_pgain_quantile_dom)
colnames(pgain_quant_dom) <- as.character(AFs)
}

name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
name_pgains[m] <- paste0("pgain_quant_",pgain_types[m])
}

if (length(pgain_types)==1){
list_pgains_quant <- list(get(name_pgains[1]))
}

if (length(pgain_types)==2){
list_pgains_quant <- list(get(name_pgains[1]), get(name_pgains[2]))
}

if (length(pgain_types)==3){
list_pgains_quant <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]))
}

names(list_pgains_quant) <- pgain_types


invisible(list_pgains_quant)

}



#' Computation of log-linear fit of the pgain-quantiles (dependent on the number of tests) and evaluation for a determined number of tests
#'
#' @name p_gain_quantile_fit
#' @param pgain_types    Character vector of the types of p-gains, of which the quantiles were computed in the function p_gain_quantiles. ("add" means additive p-gain, "rec" means recessive p-gain, "dom" means dominant p-gain) (default = c("add","rec")).
#' @param pgain_quantile    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe pgain-quantiles for different allele frequenciey (numeric values) and rows discribe number of tests. Output of function p_gain_quantiles.
#' @param n_data_ff    Integer. Number of quantile datapoints that should be used for the plot. n_data_ff is a divider of the number of available datapoints (default = nrow(pgain_quantile[[1]])).
#' @param start_vec    list of data frames. For every type of p-gain there is a data frame (in the same order as they are listed in pgain_types). Columns describe 3 starting estimates (numeric values) for the log-linear fit for each allele frequency (default is c(1,0.01,1.01) for every p-gain type and for every allele frequency).
#' @param test_number    Integer. Number of tests for which the p-gain threshold should be determined.
#' @return list_fits as a list, plots of log-linear fit of the quantiles for every allele frequency, approximated quantile for test_number many tests for every allele frequency. The list contains for every p-gain type a list with the log-linear fits for every allele frequency. 
#'
#' @examples			
#' sim_data <- p_gain_simulation(pgain_types=c("add","rec"), AFs=c(0.1,0.5),n=10000L,snps_per_trait=1L,n_study=1000L,cores=2L)   
#' pgain_quantile <- p_gain_quantiles(pgain_types=c("add","rec"), n_tests=50L,sim_data)
#' list_fits <- p_gain_quantile_fit(pgain_types=c("add","rec"),pgain_quantile,n_data_ff=nrow(pgain_quantile[[1]]),start_vec=list(data.frame(c(1.09,0.012,1.014),c(1.12,0.014,1.019)),data.frame(c(1.09,0.012,1.014),c(1.12,0.014,1.019))),test_number=200L)
#'
#' @export
p_gain_quantile_fit<-function(pgain_types=c("add","rec"),pgain_quantile,n_data_ff=nrow(pgain_quantile[[1]]),start_vec=lapply(1:length(pgain_types), function(x) data.frame(matrix(rep(c(1,0.01,1.01),times=ncol(pgain_quantile[[1]])),ncol=ncol(pgain_quantile[[1]]),dimnames=list(row.names=c("a","b","d"),col.names=colnames(pgain_quantile[[1]]))))),test_number)
{

if (is.null(pgain_types) || !is.character(pgain_types) || !all(pgain_types %in% names(pgain_quantile)))
stop("pgainsim: Error: pgain_types must be a character vector with elements of the type add, rec, dom and the quantiles of the types of p-gains must be contained in pgain_quantile.")

if (is.null(pgain_quantile) || !is.list(pgain_quantile) || length(pgain_quantile)<length(pgain_types))
stop("pgainsim: Error: pgain_quantile must be a list of length equal or greater than the length of pgain_types.")

if (is.null(n_data_ff) || !is.integer(n_data_ff) || !nrow(pgain_quantile[[1]])%%n_data_ff==0)
stop("pgainsim: Error: n_data_ff must be an integer and a divider of the number of available datapoints.")

if (is.null(start_vec) || !is.list(start_vec) || !length(start_vec)==length(pgain_types) || !ncol(start_vec[[1]])==ncol(pgain_quantile[[1]]) || !nrow(start_vec[[1]])==3 || !sum(!(sapply(start_vec[[1]],class))=="numeric")==0)
stop("pgainsim: Error: start_vec must be a list with the same length as pgain_types and every data frame in the list must have the same number of columns as pgain_quantile[[1]] and with 3 rows and with numeric values.")

if (is.null(test_number) || !is.integer(test_number))
stop("pgainsim: Error: test_number must be an integer.")


AFs <- as.numeric(colnames(pgain_quantile[[1]]))

number_tests <- c(1:nrow(pgain_quantile[[1]]))




if (!length(grep("add", pgain_types, fixed=TRUE))==0){

fits_add <- vector("list",length=length(AFs))

for(i in 1:length(AFs)){

AF <- AFs[i]

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_add <- grep("add", names(pgain_quantile), fixed=TRUE)
quantile_red_add <- pgain_quantile[[index_add]][,i][seq(1,nrow(pgain_quantile[[index_add]]),a)]




number_tests_red_add <- number_tests[seq(1,nrow(pgain_quantile[[index_add]]),a)]

index2_add <- grep("add", pgain_types, fixed=TRUE)

print(paste0("Fitted function for additive p-gain-quantiles of allele frequency ",AF))

print(fits_add[[i]] <- nlsLM(formula=pgain_quantile[[index_add]][,i]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_add]][1,i],b=start_vec[[index2_add]][2,i],d=start_vec[[index2_add]][3,i]), control=nls.control(maxiter = 1000)))
pdf(paste0("Plot_#tests_vs_add_pgain_quantile_",AF,"_log-linear_fit.pdf"))
plot(number_tests_red_add,quantile_red_add, main=paste0("#tests vs add pgain-quantile ", AF," log-linear fit"))
lines(number_tests_red_add, predict(fits_add[[i]]), col="red", type="l")
dev.off()

print_text_add <- paste0("additive p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_add)
print(log(coef(fits_add[[i]])[1] + coef(fits_add[[i]])[2]*test_number,base=coef(fits_add[[i]])[3]))


}


}




if (!length(grep("rec", pgain_types, fixed=TRUE))==0){

fits_rec <- vector("list",length=length(AFs))

for(i in 1:length(AFs)){

AF <- AFs[i]

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_rec <- grep("rec", names(pgain_quantile), fixed=TRUE)
quantile_red_rec <- pgain_quantile[[index_rec]][,i][seq(1,nrow(pgain_quantile[[index_rec]]),a)]




number_tests_red_rec <- number_tests[seq(1,nrow(pgain_quantile[[index_rec]]),a)]

index2_rec <- grep("rec", pgain_types, fixed=TRUE)

print(paste0("Fitted function for recessive p-gain-quantiles of allele frequency ",AF))

print(fits_rec[[i]] <- nlsLM(formula=pgain_quantile[[index_rec]][,i]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_rec]][1,i],b=start_vec[[index2_rec]][2,i],d=start_vec[[index2_rec]][3,i]), control=nls.control(maxiter = 1000)))
pdf(paste0("Plot_#tests_vs_rec_pgain_quantile_",AF,"_log-linear_fit.pdf"))
plot(number_tests_red_rec,quantile_red_rec, main=paste0("#tests vs rec pgain-quantile ", AF," log-linear fit"))
lines(number_tests_red_rec, predict(fits_rec[[i]]), col="red", type="l")
dev.off()

print_text_rec <- paste0("recessive p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_rec)
print(log(coef(fits_rec[[i]])[1] + coef(fits_rec[[i]])[2]*test_number,base=coef(fits_rec[[i]])[3]))


}


}





if (!length(grep("dom", pgain_types, fixed=TRUE))==0){

fits_dom <- vector("list",length=length(AFs))

for(i in 1:length(AFs)){

AF <- AFs[i]

a <- nrow(pgain_quantile[[1]])/n_data_ff


index_dom <- grep("dom", names(pgain_quantile), fixed=TRUE)
quantile_red_dom <- pgain_quantile[[index_dom]][,i][seq(1,nrow(pgain_quantile[[index_dom]]),a)]




number_tests_red_dom <- number_tests[seq(1,nrow(pgain_quantile[[index_dom]]),a)]

index2_dom <- grep("dom", pgain_types, fixed=TRUE)

print(paste0("Fitted function for dominant p-gain-quantiles of allele frequency ",AF))

print(fits_dom[[i]] <- nlsLM(formula=pgain_quantile[[index_dom]][,i]~log(a+b*number_tests,base=d),start=list(a=start_vec[[index2_dom]][1,i],b=start_vec[[index2_dom]][2,i],d=start_vec[[index2_dom]][3,i]), control=nls.control(maxiter = 1000)))
pdf(paste0("Plot_#tests_vs_dom_pgain_quantile_",AF,"_log-linear_fit.pdf"))
plot(number_tests_red_dom,quantile_red_dom, main=paste0("#tests vs dom pgain-quantile ", AF," log-linear fit"))
lines(number_tests_red_dom, predict(fits_dom[[i]]), col="red", type="l")
dev.off()

print_text_dom <- paste0("dominant p-gain-threshold for ",test_number," tests, allele frequency ",AF)
print(print_text_dom)
print(log(coef(fits_dom[[i]])[1] + coef(fits_dom[[i]])[2]*test_number,base=coef(fits_dom[[i]])[3]))


}


}




name_pgains <- vector("character", length=length(pgain_types))
for (m in 1:length(pgain_types)){
name_pgains[m] <- paste0("fits_",pgain_types[m])
}

if (length(pgain_types)==1){
list_fits <- list(get(name_pgains[1]))
}

if (length(pgain_types)==2){
list_fits <- list(get(name_pgains[1]), get(name_pgains[2]))
}

if (length(pgain_types)==3){
list_fits <- list(get(name_pgains[1]), get(name_pgains[2]), get(name_pgains[3]))
}



names(list_fits) <- pgain_types





invisible(list_fits)

}